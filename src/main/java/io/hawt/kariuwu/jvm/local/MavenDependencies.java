package io.hawt.kariuwu.jvm.local;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.management.InstanceAlreadyExistsException;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.ServerSocket;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class MavenDependencies implements MavenDependenciesMBean {
    private static final Logger LOG = LoggerFactory.getLogger(MavenDependencies.class);

    private MBeanServer mBeanServer;
    private ObjectName objectName;
//    private static final String FILE_PATH = "target/found-cves.json";
    private static final String FILE_PATH = "target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst";

    protected static final Map<String, String> VM_ALIAS_MAP = new HashMap<>();
    protected static final Map<String, String> VM_ALIAS_OVERRIDE_MAP = new HashMap<>();

    static {
        // Hawtio
        VM_ALIAS_MAP.put("hawtio-app", "Hawtio");
        VM_ALIAS_MAP.put("main.HawtioJBang", "Hawtio JBang");

        // Apache Camel
        VM_ALIAS_MAP.put("org.apache.camel:camel-maven-plugin:run", "Apache Camel");
        VM_ALIAS_MAP.put("camel:run", "Apache Camel");
        VM_ALIAS_MAP.put("main.CamelJBang", "Camel JBang");

        // Quarkus
        VM_ALIAS_MAP.put("quarkus-run.jar", "Quarkus");
        VM_ALIAS_MAP.put("quarkus-dev.jar", "Quarkus Dev");

        // Spring Boot
        VM_ALIAS_MAP.put("org.codehaus.plexus.classworlds.launcher.Launcher spring-boot:run", "Spring Boot");
        VM_ALIAS_MAP.put("org.springframework.boot.loader.JarLauncher shell", "Spring Boot Shell");

        // IntelliJ IDEA
        VM_ALIAS_MAP.put("com.intellij.idea.Main", "IntelliJ IDEA");
        VM_ALIAS_MAP.put("com.intellij.rt.execution.application.AppMain", "IntelliJ IDEA");
        VM_ALIAS_MAP.put("org.jetbrains.idea.maven.server.RemoteMavenServer", "IntelliJ IDEA");
        VM_ALIAS_MAP.put("idea maven server", "IntelliJ IDEA");
        VM_ALIAS_MAP.put("IntelliJ IDEA", "IntelliJ IDEA");

        VM_ALIAS_MAP.put("org.apache.karaf.main.Main", "Apache Karaf");
        VM_ALIAS_MAP.put("activemq.jar start", "Apache ActiveMQ");

        VM_ALIAS_MAP.put("org.apache.catalina", "Apache Tomcat");

        VM_ALIAS_MAP.put("jetty", "Jetty");

        VM_ALIAS_MAP.put("org.eclipse.equinox.launcher.Main", "Eclipse Equinox");

        VM_ALIAS_MAP.put("scala.tools.nsc.MainGenericRunner", "Scala REPL");

        VM_ALIAS_MAP.put("org.codehaus.groovy.tools.shell.Main", "Groovy Shell");
        VM_ALIAS_MAP.put("org.codehaus.groovy.tools.GroovyStarter", "Groovy Starter");

        VM_ALIAS_MAP.put("jboss-eap-6.1/jboss-modules.jar", "JBoss EAP 6");
        VM_ALIAS_MAP.put("wildfly", "WildFly");

        VM_ALIAS_MAP.put("target/surefire", "Maven Surefire Test");

        VM_ALIAS_MAP.put("org.jboss.forge.bootstrap.Bootstrap", "JBoss Forge Shell");

        VM_ALIAS_OVERRIDE_MAP.put("${zk:root/http}/jolokia", "Fabric8");
    }

    public MavenDependencies() {
        try {
            mBeanServer = ManagementFactory.getPlatformMBeanServer();
            objectName = new ObjectName("io.hawt.jvm:type=MavenDependencies");
            mBeanServer.registerMBean(this, objectName);
            System.out.println("JMX MBean registered: " + objectName);
        } catch (Exception e) {
            throw new RuntimeException("Failed to register MBean: ", e);
        }
    }

    public void init() {
        LOG.debug("Registering JVM discovery MBean: hawtio:type=io.hawt.kariuwu.jvm.local.MavenDependencies");

        try {
            try {
                // let's just hit any errors we're going to hit before even creating the mbean
                getDependencies();
            } catch (LinkageError e) {
                // Some JVM's don't support com.sun.tools.attach.VirtualMachine
                LOG.warn(
                        "Local JVM discovery disabled as this JVM cannot access com.sun.tools.attach.VirtualMachine due to: {}",
                        e.getMessage());
                return;
            }

            if (objectName == null) {
                objectName = new ObjectName("hawtio:type=io.hawt.kariuwu.jvm.local.MavenDependencies");
            }
            if (mBeanServer == null) {
                mBeanServer = ManagementFactory.getPlatformMBeanServer();
            }
            try {
                mBeanServer.registerMBean(this, objectName);
            } catch (InstanceAlreadyExistsException iaee) {
                // Try to remove and re-register
                LOG.info("Re-registering SchemaLookup MBean");
                mBeanServer.unregisterMBean(objectName);
                mBeanServer.registerMBean(this, objectName);
            }
        } catch (Exception e) {
            LOG.warn("Exception during initialization: ", e);
            throw new RuntimeException(e);
        }

        LOG.info("Registered JVM discovery MBean: hawtio:type=io.hawt.kariuwu.jvm.local.MavenDependencies");
    }

    public void destroy() {
        try {
            if (objectName != null && mBeanServer != null) {
                mBeanServer.unregisterMBean(objectName);
            }
        } catch (Exception e) {
            LOG.warn("Exception unregistering mbean: ", e);
            throw new RuntimeException(e);
        }
    }


    @Override
    public List<String> getDependencies() {
        try {
            System.out.println("----GETTING DEPENDENCIES----");
            return Files.lines(Paths.get(FILE_PATH)).collect(Collectors.toList());
        } catch (IOException e) {
            throw new RuntimeException("Failed to read dependences from maven plugin due to the  " +e);
        }
    }

    public static void main(String[] args) {
        MavenDependencies mavenDependencies = new MavenDependencies();
        System.out.println(" Dependencies: ");
        System.out.println(mavenDependencies.getDependencies());



        // Keep the application running
        try {
            Thread.sleep(Long.MAX_VALUE);
        } catch (InterruptedException ignored) {
        }
    }

}





